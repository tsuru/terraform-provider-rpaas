// Copyright 2021 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package provider

import (
	"context"
	"crypto/tls"
	"fmt"
	"net"
	"net/http"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/retry"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	tsuruclient "github.com/tsuru/go-tsuruclient/pkg/client"
	"github.com/tsuru/go-tsuruclient/pkg/config"
	rpaasclient "github.com/tsuru/rpaas-operator/pkg/rpaas/client"
	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
)

var Version string = "undefined"

func Provider() *schema.Provider {
	return &schema.Provider{
		Schema: map[string]*schema.Schema{
			"rpaas_url": {
				Type:        schema.TypeString,
				Description: "URL address for RPaaS API.",
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("RPAAS_URL", nil),
			},
			"rpaas_user": {
				Type:        schema.TypeString,
				Description: "Username to authenticate on RPaaS API.",
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("RPAAS_USER", nil),
			},
			"rpaas_password": {
				Type:        schema.TypeString,
				Description: "Password to authentication on RPaaS API",
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("RPAAS_PASSWORD", nil),
			},
			"tsuru_target": {
				Type:        schema.TypeString,
				Description: "URL address for Tsuru API.",
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("TSURU_TARGET", nil),
			},
			"tsuru_token": {
				Type:        schema.TypeString,
				Description: "Authentication token for Tsuru API.",
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("TSURU_TOKEN", nil),
			},
			"http_timeout_in_seconds": {
				Type:        schema.TypeInt,
				Description: "Timeout in seconds a HTTP request can take. Zero means no limit.",
				Default:     0,
				Optional:    true,
			},
			"skip_cert_verification": {
				Type:        schema.TypeBool,
				Description: "Whether should skip certificate verification during TLS protocol.",
				Optional:    true,
				DefaultFunc: schema.EnvDefaultFunc("SKIP_CERT_VERIFICATION", nil),
			},
		},
		ResourcesMap: map[string]*schema.Resource{
			"rpaas_autoscale":    resourceRpaasAutoscale(),
			"rpaas_block":        resourceRpaasBlock(),
			"rpaas_route":        resourceRpaasRoute(),
			"rpaas_certificate":  resourceRpaasCertificate(),
			"rpaas_cert_manager": resourceRpaasCertManager(),
			"rpaas_acl":          resourceRpaasACL(),
			"rpaas_file":         resourceRpaasFile(),
		},
		ConfigureContextFunc: func(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) {
			return providerConfigure(ctx, d)
		},
	}
}

type rpaasProvider struct {
	RpaasClient rpaasclient.Client
	opts        *ProviderConfigOptions
}

func (rp *rpaasProvider) Client(service, instance string) *autogenerated.APIClient {
	opts := *rp.opts
	opts.TsuruService = service
	opts.TsuruInstance = instance

	return getAutogeneratedClient(&opts)
}

func providerConfigure(ctx context.Context, d *schema.ResourceData) (interface{}, diag.Diagnostics) {
	providerOpts, err := getProviderConfigOpts(d)
	if err != nil {
		return nil, diag.FromErr(err)
	}

	legacyClient, err := getLegacyClient(providerOpts)
	if err != nil {
		return nil, diag.FromErr(err)
	}

	return &rpaasProvider{
		RpaasClient: legacyClient,
		opts:        providerOpts,
	}, nil
}

type ProviderConfigOptions struct {
	URL                string
	Username           string
	Password           string
	TsuruTarget        string
	TsuruToken         string
	TsuruService       string
	TsuruInstance      string
	Timeout            time.Duration
	InsecureSkipVerify bool
}

func getProviderConfigOpts(d *schema.ResourceData) (*ProviderConfigOptions, error) {
	var opts ProviderConfigOptions

	if v, ok := d.GetOk("rpaas_url"); ok {
		opts.URL = v.(string)
	}

	if v, ok := d.GetOk("rpaas_user"); ok {
		opts.Username = v.(string)
	}

	if v, ok := d.GetOk("rpaas_password"); ok {
		opts.Password = v.(string)
	}

	if v, ok := d.GetOk("tsuru_target"); ok {
		opts.TsuruTarget = v.(string)
	}

	if v, ok := d.GetOk("tsuru_token"); ok {
		opts.TsuruToken = v.(string)
	}

	if v, ok := d.GetOk("http_timeout_in_seconds"); ok {
		opts.Timeout = time.Duration(v.(int)) * time.Second
	}

	if v, ok := d.GetOk("skip_cert_verification"); ok {
		opts.InsecureSkipVerify = v.(bool)
	}

	if opts.TsuruTarget != "" {
		target, err := config.ReadTarget()
		if err != nil {
			return nil, err
		}

		opts.TsuruTarget = target
	}

	if opts.TsuruTarget != "" && opts.TsuruToken == "" {
		token, err := readToken()
		if err != nil {
			return nil, err
		}

		opts.TsuruToken = token
	}

	return &opts, nil
}

func getLegacyClient(opts *ProviderConfigOptions) (rpaasclient.Client, error) {
	legacyClientOpts := rpaasclient.ClientOptions{
		InsecureSkipVerify: opts.InsecureSkipVerify,
		Timeout:            opts.Timeout,
	}

	if opts.URL != "" {
		return rpaasclient.NewClientWithOptions(opts.URL, opts.Username, opts.Password, legacyClientOpts)
	}

	service := "unset"
	if opts.TsuruService != "" {
		service = opts.TsuruService
	}

	if opts.TsuruToken == "" {
		token, err := readToken()
		if err != nil {
			return nil, err
		}

		opts.TsuruToken = token
	}

	return rpaasclient.NewClientThroughTsuruWithOptions(opts.TsuruTarget, opts.TsuruToken, service, legacyClientOpts)
}

func readToken() (string, error) {
	_, tokenProvider, err := tsuruclient.RoundTripperAndTokenProvider()
	if err != nil {
		return "", err
	}
	return tokenProvider.Token()
}

func getAutogeneratedClient(opts *ProviderConfigOptions) *autogenerated.APIClient {
	serverURL := opts.URL
	if serverURL == "" {
		serverURL = opts.TsuruTarget
	}

	cfg := &autogenerated.Configuration{
		Servers: autogenerated.ServerConfigurations{{URL: serverURL}},
		HTTPClient: &http.Client{
			Transport: baseHTTPTransport(opts.InsecureSkipVerify),
			Timeout:   opts.Timeout,
		},
		UserAgent: fmt.Sprintf("terraform-provider-rpaas/%s", Version),
	}

	if opts.URL != "" && opts.Username != "" && opts.Password != "" {
		cfg.HTTPClient.Transport = &rpaasclient.BasicAuthTransport{
			Username: opts.Username,
			Password: opts.Password,
			Base:     cfg.HTTPClient.Transport,
		}
	} else if opts.TsuruTarget != "" {
		cfg.HTTPClient.Transport = &tsuruclient.TsuruProxyTransport{
			Target:   opts.TsuruTarget,
			Token:    opts.TsuruToken,
			Service:  opts.TsuruService,
			Instance: opts.TsuruInstance,
			Base:     cfg.HTTPClient.Transport,
		}
	}

	return autogenerated.NewAPIClient(cfg)
}

func rpaasRetry(ctx context.Context, timeout time.Duration, retryFunc func() (*http.Response, error)) error {
	return retry.RetryContext(ctx, timeout, func() *retry.RetryError {
		response, err := retryFunc()
		if err != nil && tsuruclient.IsTsuruEventLocked(response, err) {
			return retry.RetryableError(err)
		}

		if err != nil {
			return retry.NonRetryableError(err)
		}

		return nil
	})
}

func parseRpaasInstanceID(id string) (serviceName, instance string, err error) {
	parts := strings.Split(id, "::")
	if len(parts) != 2 {
		serviceName, instance, err = parseRpaasInstanceID_legacyV0(id)
		if err != nil {
			err = fmt.Errorf("Could not parse id %q. Format should be service::instance", id)
		}
		return
	}

	return parts[0], parts[1], nil
}

func parseRpaasInstanceID_legacyV0(id string) (serviceName, instance string, err error) {
	parts := strings.Split(id, "/")
	if len(parts) != 2 {
		return "", "", fmt.Errorf("Legacy ID cound not be parsed. Legacy format: service/instance")
	}

	return parts[0], parts[1], nil
}

func baseHTTPTransport(insecure bool) http.RoundTripper {
	return &http.Transport{
		Proxy: http.ProxyFromEnvironment,
		DialContext: (&net.Dialer{
			Timeout:   30 * time.Second,
			KeepAlive: 30 * time.Second,
		}).DialContext,
		ForceAttemptHTTP2:     true,
		MaxIdleConns:          100,
		IdleConnTimeout:       90 * time.Second,
		TLSHandshakeTimeout:   10 * time.Second,
		ExpectContinueTimeout: 1 * time.Second,
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: insecure,
		},
	}
}
